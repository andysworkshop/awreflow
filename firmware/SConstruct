#
# Build script for Andy's Workshop Reflow Controller (awreflow)
#

# These variables must be set correctly

STM32PLUS_INSTALL_DIR = "/usr/lib/stm32plus"
STM32PLUS_VERSION     = "030300"

# main build script

import os
import os.path
import platform
from subprocess import check_output

def usage():

    print """
Usage: scons mode=<MODE>

  <MODE>: debug/fast/small.
    debug = -O0
    fast  = -O3
    small = -Os

  Examples using -j to do a 4-job parallel build:
    scons mode=debug -j4
    scons mode=fast -j4
    scons mode=small -j4
"""

# mode argument must be supplied

mode=ARGUMENTS.get('mode')

if not (mode in ['debug', 'fast', 'small']):
    usage()
    Exit(1)

# set up build environment and pull in OS environment variables

env=Environment(ENV=os.environ)

# verify that stm32plus is installed in the defined location

STM32PLUS_ROOT=STM32PLUS_INSTALL_DIR+"/"+STM32PLUS_VERSION

stm32plus_lib=STM32PLUS_ROOT+"/libstm32plus-"+STM32PLUS_VERSION+"-"+mode+"-f051-8000000.a"
if not os.path.isfile(stm32plus_lib):
    print stm32plus_file+" does not exist."
    print "Please edit SConstruct and check the STM32PLUS_INSTALL_DIR and STM32PLUS_VERSION variables."
    Exit(1)

# replace the compiler values in the environment

env.Replace(CC="arm-none-eabi-gcc")
env.Replace(CXX="arm-none-eabi-g++")
env.Replace(AS="arm-none-eabi-as")

# create the C and C++ flags that are needed. We can't use the extra or pedantic errors on the ST library code.

env.Replace(CCFLAGS=["-Wall","-Werror","-ffunction-sections","-fdata-sections","-fno-exceptions","-mthumb","-gdwarf-2","-pipe","-mcpu=cortex-m0","-DSTM32PLUS_F0_51","-DHSE_VALUE=8000000"])
env.Replace(CXXFLAGS=["-Wextra","-pedantic-errors","-fno-rtti","-std=gnu++0x","-fno-threadsafe-statics"])
env.Append(ASFLAGS="-mcpu=cortex-m0")
env.Append(LINKFLAGS=["-Xlinker","--gc-sections","-mthumb","-g3","-gdwarf-2","-mcpu=cortex-m0"])
env.Append(LINKFLAGS=["-Tsystem/f051/Linker.ld","-Wl,-wrap,__aeabi_unwind_cpp_pr0","-Wl,-wrap,__aeabi_unwind_cpp_pr1","-Wl,-wrap,__aeabi_unwind_cpp_pr2"])

# set the include directories

env.Append(CPPPATH=["include",
    STM32PLUS_ROOT+"/include",
    STM32PLUS_ROOT+"/include/stl",
    STM32PLUS_ROOT])

env.Append(CPPPATH=["include"])

# set the library path

env.Append(LIBS="stm32plus-"+STM32PLUS_VERSION+"-"+mode+"-f051-8000000.a")
env.Append(LIBPATH=STM32PLUS_ROOT)

# collect the source files

matches=[]
matches.append(Glob("src/*.cpp"))

# append the system startup files

matches.append("system/LibraryHacks.cpp")
matches.append("system/f051/Startup.asm")
matches.append("system/f051/System.c")

# here's where the linker script is located

linkerscript="system/f051/Linker.ld"

# add on the mode=specific optimisation definitions

if mode=="debug":
    env.Append(CCFLAGS=["-O0","-g3"])
elif mode=="fast":
    env.Append(CCFLAGS=["-O3"])
elif mode=="small":
    env.Append(CCFLAGS=["-Os"])

# trigger a build with the correct output name

elf=env.Program("awreflow.elf",matches)
hex=env.Command("awreflow.hex",elf,"arm-none-eabi-objcopy -O ihex awreflow.elf awreflow.hex")
bin=env.Command("awreflow.bin",elf,"arm-none-eabi-objcopy -O binary awreflow.elf awreflow.bin")
lst=env.Command("awreflow.lst",elf,"arm-none-eabi-objdump -h -S awreflow.elf > awreflow.lst")
size=env.Command("awreflow.size",elf,"arm-none-eabi-size --format=berkeley awreflow.elf | tee awreflow.size")
